Формулировка проблемы и задачи, которую решаем:
Для создания проекта была создана команда разнонаправленных специалистов, знания и умения которых необходимы для успешного выполнения работы. Однако каждый сотрудник обладает разной степенью квалификации в той или иной области, из-за чего эффективность выполнения им различных задач может отличаться.
Необходимо, обладая информацией об эффективности задействования специалистов в каждой из областей, оптимально рапределить обязанности для наиболее успешного выполнения ими совместной работы.

<<Чтобы решить данную задачу, используем граф>>
<<Теория графов(есть на хабре)
тут же объянить работу функции findMaxMatching - поиск макс парасочетания>>
<<Про входные данные>>

Про то, что написано в коде:
Итак, входные данные были преобразованы в матрицу M эффективности рабочего коллектива, где строки - специалисты, столбцы - задачи.
Перед началом работы алгоритма инициализируем все необходимые для его работы переменные.
Пользуясь знанием параметра "эффективность", разделим указанные на ребрах величины на 2 других параметра, соответсвующие вершинам, которые соединяет ребро:
"способность" - характеристика специалиста (объем силы, которая есть у работника для выполнения задачи)
"изученность" - характеристика задачи (сколько при выполнении данной задачи еще останется свободных сил)
Например, специалист A обладает способностью 7, а задача X - изученностью 3. Подразумевается, что если А выполняет X, то эффективность этого равна 10: работник сделал успешно сделал работу (справился с задачей на 7) и, например, успел помочь коллеге в его заданием (за счет этого повысил эффективность на 3).
Получается такое равенство:
эффективность выполнения специалистом конкретной задачи = способность разработчика + изученность задачи.

Вектор vector<int> skill содержит "способности" специалистов. В начале инициализируем максимальным значением эффективности, которое соответсвует максимальному число в строке матрицы M. То есть считаем, что каждый специалист занимается самым подходящим для него работой.
Вектор vector<int> understanding инициализируется нулями, потому что все и так работают на пределе возможностей, свободных сил не остается.
Векторы vector<bool> vertexX, vertexY содержат информацию о задействованности вершин "специалистов" и "задач" (содержатся ли в альтернирующем дереве).
Векторы vector<int> xy, yx содержат информацию о парасочетаниях (в xy указывается, какой задачей занимается i-ый специалист, а в yx - кто делает работу j, где i, j - индексы элементов в векторах).  Перед началом работы все сотрудники свободны, никто не работает.

Приступаем к самому алгоритму. Берем по очереди всех незадействованных сотрудников и назначем каждому свободную задачу, строим альтернирующее дерево. Тут руководствуемся правилом построение графа равенства (Equality Graph))
На данном этапе используется функция findMaxMatching.:
эффективность решения задачи (ребро) = способность разработчика (вершина) + изученность задачи (вершина) 
Если удалость найти свободную задачу, то дерево стало аугментальным. «Переназначаем» задачи (обновление vertexX и vertexY), наращиваем паросочетание. Снова строим альтернирующее дерево.
Если же свободных задач (найденных в соответсвии с вышеупомянутым правилом) нет (k = 0), то полученное дерево - Венгерское. В данном случае мы изменяем разметку вершин (пересчитываем "способности" и "изученности"). 
В цикле ищем ребра, соединающие таких разработчиков, которые либо незадействованы, либо доступны из незадействованных (можно переназначить), и нераспределенные задачи. Вычислем  минимальное на текущий момент «несоответствие» способностей разработчика, чтобы он смог приступить к этой задаче: delta = min(способность разработчика (вершина) + изученность задачи (вершина) — эффективность решения задачи (ребро)).
Понижаем способности содержащихся в альтернирующем дереве специалистов (vertexX[i] == true) и повышаем изученность оттуда же (vertexY[i] == true) задач на delta. В результате этого действия граф все еще является графом равенства, однако теперь мы можем продолжать присоединять ребра к альтернирующему дереву.
Понизив "способности" разработчиков и "повысив" изученности задач, мы назначаем специалистам задания, в меньшей степени соответсвующие их квалификации, но компенсируем это увеличением количества у них сил на помощь коллегам в вопросах, в которых переназначенные работники были более компетентны. В сумме задача становится более изученной.

Описания выходных данных:
В качестве выходных данных программа выводит в файл с названием "Reult" результат работы программы. В первой строке содержится число - максимальная эффективности деятильности компании, а в следующих n строках (где n - количество сотрудников) - информация об оптимальном распределении обязанностей между сотрудниками.
